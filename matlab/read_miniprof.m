function [ p ] = read_miniprof(fname, idebug, make_plot)

% function [ p ] = read_miniprof(fname, [idebug], [make_plot])
%
% Lower-level routine for reading wheel/rail profiles in Miniprof format.
% Does not do automatic corrections like mirroring or reversing order.
%
%   fname     - filename of input file
%   make_plot - figure number to use for plotting the profile

% Copyright 2008-2023 by Vtech CMCC.
%
% Licensed under Apache License v2.0.  See the file "LICENSE.txt" for more information.

if (nargin<2 | isempty(idebug))
   idebug = 1;
end
if (nargin<3 | isempty(make_plot))
   make_plot = 0;
end

keep_keyword_values = 0;

known_fields = struct( ...
   'AlarmFailureCount',             'int', ...
   'AlarmWarningCount',             'int', ...
   'AlignDA',                       'unknown', ...
   'AlignDX',                       'unknown', ...
   'AlignDY',                       'unknown', ...
   'AlignOX',                       'unknown', ...
   'AlignOY',                       'unknown', ...
   'AreaGain',                      'unknown', ...
   'AreaLoss',                      'unknown', ...
   'AreaRef',                       'unknown', ...
   'AxleNo',                        'int', ...
   'BaseOffset',                    'unknown', ...
   'BaseTilt',                      'unknown', ...
   'Battery_Capacity',              'real', ...
   'Battery_Level',                 'real', ...
   'Bogie',                         'int', ...
   'CarNo',                         'int', ...
   'Chainage',                      'str', ...
   'Chars',                         'str', ...
   'ColumnDef',                     'str', ...
   'Comment',                       'str', ...
   'CrownR',                        'real', ...
   'CrownRadius',                   'real', ...
   'Curve',                         'str', ...
   'Date',                          'str', ...
   'DiameterFlange',                'real', ...
   'DiameterFlange_AlarmStatus',    'int', ...
   'DiameterTaperline',             'real', ...
   'DiameterTaperline_AlarmStatus', 'int', ...
   'Direction',                     'str', ...
   'Elevation',                     'real', ...
   'EmplNum',                       'int', ...
   'FileName',                      'str', ...
   'Flag',                          'unknown', ...
   'Flat',                          'unknown', ...
   'Gauge',                         'real', ...
   'Gauge_AlarmStatus',             'int', ...
   'GaugeRodLength',                'real', ...
   'GaugeSensorDistance',           'real', ...
   'GaugeSensorSamples',            'real', ...
   'GaugeSensorStdDev',             'real', ...
   'Grade',                         'real', ...
   'GradeRatio',                    'real', ...
   'Instrument_Connection',         'int', ...
   'Instrument_Firmware',           'str', ...
   'KP',                            'unknown', ...
   'Line',                          'str', ...
   'Location_Altitude',             'real', ...
   'Location_HorizontalAccuracy',   'real', ...
   'Location_Latitude',             'real', ...
   'Location_Longitude',            'real', ...
   'Location_VerticalAccuracy',     'real', ...
   'Mileage',                       'str', ...
   'MPCalDate',                     'str', ...
   'MPCalTime',                     'str', ...
   'MPD1',                          'int', ...
   'MPD2',                          'int', ...
   'MPD3',                          'int', ...
   'MPD4',                          'int', ...
   'MPD5',                          'int', ...
   'MPD6',                          'int', ...
   'MPD7',                          'int', ...
   'MPD8',                          'int', ...
   'MPD9',                          'int', ...
   'MPD10',                         'int', ...
   'MPD11',                         'int', ...
   'MPD12',                         'int', ...
   'MPD13',                         'int', ...
   'MPD14',                         'int', ...
   'MPD15',                         'int', ...
   'MPD16',                         'int', ...
   'MPD17',                         'int', ...
   'MPD18',                         'int', ...
   'MPD19',                         'int', ...
   'MPDC',                          'int', ...
   'MPDN',                          'str', ...
   'MPSerNo',                       'int', ...
   'MPTypeNo',                      'int', ...
   'OriginalHeader',                'unknown', ...
   'Position',                      'str', ...
   'ProfileAlignment',              'unknown', ...
   'ProfileShaping',                'unknown', ...
   'ProgramDate',                   'str', ...
   'ProgramName',                   'str', ...
   'ProgramVer',                    'str', ...
   'qR',                            'real', ...
   'qR_AlarmStatus',                'int', ... 
   'Rail',                          'str', ...
   'RailAlignType',                 'int', ...
   'RailAngle',                     'real', ...
   'RailAngle_AlarmStatus',         'int', ...
   'RailGaugePoint',                'str', ...
   'RailRodLength',                 'str', ...
   'RCF',                           'unknown', ...
   'ReferenceProfile',              'str', ...
   'RefPoint1',                     'real', ...
   'RefPoint2',                     'real', ...
   'RefPoint3',                     'real', ...
   'RefPoint4',                     'real', ...
   'RefPoint5',                     'real', ...
   'RefPoint6',                     'real', ...
   'RefPoint7',                     'real', ...
   'RefPoint8',                     'real', ...
   'RefPoint9',                     'real', ...
   'RodLength',                     'real', ...
   'Sd',                            'real', ...
   'Sd_AlarmStatus',                'int', ...
   'SectionNo',                     'unknown', ...
   'Sh',                            'real', ... 
   'Sh_AlarmStatus',                'int', ... 
   'SuperElevation',                'real', ...
   'SuperElevationHeight',          'real', ...
   'Side',                          'str', ...
   'Stock',                         'str', ...
   'SurfaceCondition',              'unknown', ...
   'Temperature',                   'real', ...
   'Tilt',                          'unknown', ...
   'Time',                          'str', ...
   'Track',                         'str', ...
   'TrackSection',                  'unknown', ...
   'Transformation',                'str', ...
   'TransformState',                'str', ...
   'UOF1',                          'str', ...
   'UOF2',                          'str', ...
   'UOF3',                          'str', ...
   'UOF4',                          'str', ...
   'UserName',                      'str', ...
   'W1',                            'real', ...
   'W1_AlarmLevel',                 'real', ...
   'W1_AlarmStatus',                'int', ...
   'W2',                            'real', ...
   'W2_AlarmStatus',                'int', ...
   'W3',                            'real', ...
   'W3_AlarmStatus',                'int', ...
   'WheelAdjustPoint',              'real', ...
   'WheelDiameterTaperline',        'real', ...
   'WheelID',                       'int', ...
   'Windows_ComputerName',          'str', ...
   'Windows_NetFramework',          'str', ...
   'Windows_ServicePack',           'str', ...
   'Windows_UserName',              'str', ...
   'Windows_Version',               'str', ...
   'Xoffset',                       'real', ...
   'Yoffset',                       'real', ...
   'XYPoints',                      'int'  ...
);


% Initialize output structure

p                  = struct;
p.ProfileData      = [];
nrows_data         = 0;
p.ProfileS         = [];
p.ProfileY         = [];
p.ProfileZ         = [];
p.ProfileAngle     = [];
p.ProfileCurvature = [];
p.ProfileKYield    = [];

if (~exist(fname,'file'))
   disp(['ERROR: cannot find file ',fname]);
   return
end
f = fopen(fname,'r');
iline = 0;
in_profile = 0;

FORMAT_UNKNOWN = 0; 
FORMAT_OLD = 1; 
FORMAT_BAN = 2; % .ban and .whl files
FORMAT_MPT = 3; % .mpt files supporting multiple profiles or profile sections
file_format = FORMAT_UNKNOWN;

while(~feof(f))
   % get next line from input
   s  = deblank(fgets(f)); 
   iline = iline + 1;
   if (idebug>=5 & iline<10)
      disp(sprintf('%4d: %s', iline, s));
   end

   % determine type of Miniprof file
   if (iline<=3 & file_format==FORMAT_UNKNOWN)
      if (strfind(s, 'MINIPROF'))
         file_format = FORMAT_OLD;
         if (idebug>=1), disp('Old style Miniprof file'); end
      elseif (strfind(s, '[FileInfo]'))
         file_format = FORMAT_MPT;
         if (idebug>=1), disp('Multi-part Miniprof file'); end
      end
   end
   if (iline>3 & file_format==FORMAT_UNKNOWN)
      file_format = FORMAT_BAN;
      if (idebug>=1), disp('Regular Miniprof file'); end
   end

   % remove comments, everything after ", !, or %
   ix = strfind(s, '"'); if (~isempty(ix)), s=s(1:ix-1); end
   ix = strfind(s, '!'); if (~isempty(ix)), s=s(1:ix-1); end
   ix = strfind(s, '%'); if (~isempty(ix)), s=s(1:ix-1); end

   if (~isempty(s) & s(1)=='[' & idebug>=1)
      disp(sprintf('Line %5d: start of section %s', iline, strtrim(s)));
   end

   % OLD, BAN-formats: data starts after empty line

   if (any(file_format==[FORMAT_OLD, FORMAT_BAN]) & isempty(strtrim(s)))

      in_profile = 1;

   % MPT-format: next profile section starts after [Profile*Points], add row of NaNs between sections

   elseif (file_format==FORMAT_MPT & strfind(s, 'Points]'))

      in_profile = in_profile + 1;
      if (idebug>=2)
         disp(sprintf('Line %5d: starting profile section %d', iline, in_profile))
      end
      if (in_profile > 1)
         nrows_data = nrows_data + 1;
         p.ProfileData(nrows_data,:) = NaN;
      end
   end

   % look for an equals sign
   ix = strfind(s,'=');

   % if found: interpret keyword=value syntax
   if (~isempty(ix))
      ix = ix(1);
      field_name = deblank(s(1:ix-1));
      field_name = strrep(field_name, '.', '_');
      field_name = strrep(field_name, ' ', '_');
      field_val  = deblank(s(ix+1:end));
      % check if the keyword is known - convert to case-sensitive name
      my_field_name = check_field(known_fields, field_name);
      if (~keep_keyword_values)
         % do not store file header keyword/value information
      elseif (~isempty(my_field_name))
         % interpret numerical value
         if (strcmp(known_fields.(my_field_name), 'int'))
            p.(my_field_name) = str2num(field_val);
         elseif (strcmp(known_fields.(my_field_name), 'real'))
            p.(my_field_name) = str2num(field_val);
         elseif (strcmp(known_fields.(my_field_name), 'num'))
            p.(my_field_name) = str2num(field_val);
         % store string value
         elseif (strcmp(known_fields.(my_field_name), 'str'))
            p.(my_field_name) = field_val;
         % unknown type: store string value if it's non-empty
         %               empty fields of type 'unknown' will be discarded
         elseif (~isempty(field_val))
            if (idebug>=2)
               disp(sprintf('Unknown field-type %s: value="%s"',field_name,field_val));
            end
            p.(my_field_name) = field_val;
         end
      % unknown keyword: report & store string value
      else
         if (idebug>=2)
            disp(sprintf('Unknown field "%s"',field_name));
         end
         p.(field_name) = field_val;
      end

   % no keyword found - interpret data line
   elseif (~isempty(s))

      ix = strfind(s, ','); if (~isempty(ix)), s(ix)=' '; end
      [tmp, cnt] = sscanf(s, '%f %f %f %f %f %f %f %f');

      if (cnt>0 & (in_profile>0 | file_format~=FORMAT_OLD))
         nrows_data = nrows_data + 1;
         p.ProfileData(nrows_data, 1:cnt) = tmp;
      end

   end % ~isempty(ix), keyword handling
end % while (~feof)
fclose(f);

if (~isfield(p, 'ColumnDef'))
   p.ColumnDef = 'X,Y,*';
   if (idebug>=2)
      disp(sprintf('Assuming columndef "%s"', p.ColumnDef));
   end
end

ncol = size(p.ProfileData,2);
KnownCols = ['X';'Y';'A';'C';'N';'K'];
for icol = 1 : length(KnownCols)
   ipos = (findstr(KnownCols(icol), p.ColumnDef) + 1) / 2;
   if (ipos)
      if (idebug>=3)
         disp(sprintf('Found column "%s" at ipos = %d', KnownCols(icol), ipos));
      end
      if     (KnownCols(icol)=='X')
         p.ProfileY         = p.ProfileData(:,ipos);
      elseif (KnownCols(icol)=='Y')
         p.ProfileZ         = p.ProfileData(:,ipos);
      elseif (KnownCols(icol)=='A')
         p.ProfileAngle     = p.ProfileData(:,ipos);
      elseif (KnownCols(icol)=='C')
         p.ProfileCurvature = p.ProfileData(:,ipos);
      elseif (KnownCols(icol)=='N')
         % ignored
      elseif (KnownCols(icol)=='K')
         p.ProfileKYield    = p.ProfileData(:,ipos);
      else
         disp(sprintf('Unknown column icol=%d, "%s"', icol, KnownCols(icol)));
      end
   elseif (icol<=2)
      disp(sprintf('Invalid ColumnDef="%s", should specify at least X,Y', p.ColumnDef));
   end
end

if (make_plot)
   figure(make_plot); clf; hold on;
   plot(p.ProfileY, p.ProfileZ, '-o');
   grid on;
   xlabel('y_{prf} [mm]'); ylabel('z_{prf} [mm]');
   set(gca,'ydir','reverse');
end

end % function read_miniprof

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [ my_field ] = check_field( known_fields, field_in )

   fn = fieldnames(known_fields);
   chk = strcmpi(field_in, fn);
   i = find(chk);
   if (isempty(i))
      my_field = [];
   else
      my_field = fn{i};
   end

end % function check_field

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

